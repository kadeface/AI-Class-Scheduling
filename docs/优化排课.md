

## 分阶段排课算法执行计划

### 项目概述
**目标**: 实现分阶段排课算法，显著提升排课成功率和性能
**当前问题**: 算法频繁达到最大迭代次数限制(10000次)，排课效率低下
**解决方案**: 将复杂排课问题分解为三个相对简单的阶段，逐步构建完整课表

### 第一阶段：核心课程排课引擎 (Week 1-2)

#### 1.1 创建核心课程引擎类
**文件路径**: `backend/src/services/scheduling/core-course-engine.ts`
**功能描述**: 专门处理核心课程（语文、数学、英语等）的排课
**核心特性**:
- 严格模式：硬约束优先，确保核心课程质量
- 高优先级：使用最优时间段和资源
- 快速收敛：简化约束，减少搜索空间

**实现内容**:
```typescript
class CoreCourseEngine {
  // 核心课程分类
  private coreSubjects: string[] = ['语文', '数学', '英语', '物理', '化学', '生物'];
  
  // 核心课程约束管理
  private coreConstraints: CoreConstraint[];
  
  // 核心课程排课算法
  public scheduleCoreCourses(): SchedulingResult;
}
```

#### 1.2 修改现有排课引擎
**文件路径**: `backend/src/services/scheduling/scheduling-engine.ts`
**修改内容**:
- 添加课程分类逻辑
- 实现核心课程过滤
- 集成核心课程引擎
- 添加阶段控制参数

**关键修改点**:
```typescript
// 在SchedulingEngine类中添加
private coreEngine: CoreCourseEngine;
private currentStage: SchedulingStage;

// 修改主排课方法
public async schedule(): Promise<SchedulingResult> {
  // 第一阶段：核心课程
  const coreResult = await this.coreEngine.scheduleCoreCourses();
  
  // 后续阶段处理...
}
```

#### 1.3 更新类型定义
**文件路径**: `backend/src/services/scheduling/types.ts`
**新增内容**:
- 课程优先级枚举
- 分阶段配置接口
- 核心课程约束类型
- 阶段状态管理

**新增类型**:
```typescript
export enum CoursePriority {
  CORE = 'core',           // 核心课程
  GENERAL = 'general',     // 一般课程
  SPECIAL = 'special'      // 特殊需求课程
}

export enum SchedulingStage {
  CORE_COURSES = 'core_courses',
  GENERAL_COURSES = 'general_courses',
  SPECIAL_REQUIREMENTS = 'special_requirements'
}

export interface StageConfig {
  maxIterations: number;
  timeLimit: number;
  enableOptimization: boolean;
}
```

### 第二阶段：一般课程排课引擎 (Week 3-4)

#### 2.1 创建一般课程引擎类
**文件路径**: `backend/src/services/scheduling/general-course-engine.ts`
**功能描述**: 处理体育、音乐、美术等一般课程
**核心特性**:
- 灵活模式：基于已有排课结果
- 中等优先级：平衡质量和效率
- 冲突解决：智能处理软约束违反

**实现内容**:
```typescript
class GeneralCourseEngine {
  // 一般课程分类
  private generalSubjects: string[] = ['体育', '音乐', '美术', '信息技术'];
  
  // 基于核心课程的约束调整
  private adjustConstraints(existingSchedule: Schedule): Constraint[];
  
  // 一般课程排课算法
  public scheduleGeneralCourses(existingSchedule: Schedule): SchedulingResult;
}
```

#### 2.2 实现约束分层管理
**文件路径**: `backend/src/services/scheduling/constraint-manager.ts`
**功能描述**: 根据排课阶段动态管理约束
**核心特性**:
- 动态约束调整
- 阶段间约束传递
- 冲突优先级管理

**实现内容**:
```typescript
class ConstraintManager {
  // 约束分层
  private hardConstraints: Constraint[];
  private softConstraints: Constraint[];
  private flexibleConstraints: Constraint[];
  
  // 阶段约束管理
  public getStageConstraints(stage: SchedulingStage): Constraint[];
  
  // 约束冲突检测
  public detectConflicts(schedule: Schedule): Conflict[];
}
```

#### 2.3 集成到主排课流程
**修改文件**: `backend/src/services/scheduling/scheduling-service.ts`
**集成内容**:
- 添加阶段控制逻辑
- 实现阶段间数据传递
- 添加进度报告机制

### 第三阶段：特殊需求处理引擎 (Week 5-6)

#### 3.1 创建特殊需求引擎类
**文件路径**: `backend/src/services/scheduling/special-requirements-engine.ts`
**功能描述**: 处理连排课程、教师轮换等特殊需求
**核心特性**:
- 智能冲突解决
- 局部优化算法
- 手动调整建议

**实现内容**:
```typescript
class SpecialRequirementsEngine {
  // 特殊需求类型
  private specialRequirements: SpecialRequirement[];
  
  // 局部优化算法
  private localOptimization(schedule: Schedule): Schedule;
  
  // 特殊需求处理
  public processSpecialRequirements(schedule: Schedule): SchedulingResult;
}
```

#### 3.2 实现局部优化算法
**算法选择**:
- 遗传算法：处理复杂约束组合
- 模拟退火：局部最优解搜索
- 禁忌搜索：避免重复搜索

**优化策略**:
- 时间槽交换优化
- 教师分配优化
- 教室利用率优化

#### 3.3 集成手动调整功能
**功能描述**: 为无法自动解决的冲突提供手动调整建议
**实现内容**:
- 冲突可视化展示
- 调整建议生成
- 手动操作接口

### 第四阶段：系统集成与测试 (Week 7-8)

#### 4.1 前端界面更新
**文件路径**: `frontend/src/app/management/schedules/integrated/page.tsx`
**更新内容**:
- 添加阶段进度显示
- 实现分阶段配置界面
- 添加排课质量指标

**新增组件**:
```typescript
// 阶段进度组件
const StageProgress: React.FC<{currentStage: SchedulingStage}>;

// 分阶段配置组件
const StageConfiguration: React.FC<{config: StageConfig}>;

// 排课质量指标组件
const QualityMetrics: React.FC<{metrics: QualityMetrics}>;
```

#### 4.2 后端API更新
**文件路径**: `backend/src/routes/scheduling-routes.ts`
**新增接口**:
- 分阶段排课接口
- 阶段进度查询接口
- 排课质量评估接口

**API设计**:
```typescript
// 分阶段排课
POST /api/scheduling/staged-schedule

// 阶段进度查询
GET /api/scheduling/stages/:taskId/progress

// 排课质量评估
GET /api/scheduling/quality/:taskId
```

#### 4.3 性能监控与优化
**监控指标**:
- 各阶段执行时间
- 迭代次数统计
- 约束满足率
- 资源利用率

**优化策略**:
- 缓存机制优化
- 并行处理优化
- 内存使用优化

### 第五阶段：部署与验证 (Week 9-10)

#### 5.1 系统部署
**部署步骤**:
1. 代码审查和测试
2. 数据库迁移脚本
3. 配置文件更新
4. 服务重启和验证

#### 5.2 性能测试
**测试内容**:
- 单阶段性能测试
- 全流程压力测试
- 大数据量测试
- 边界条件测试

**测试指标**:
- 排课成功率 > 95%
- 平均执行时间 < 60秒
- 最大迭代次数 < 5000次
- 内存使用 < 2GB

#### 5.3 用户验收测试
**测试内容**:
- 功能完整性测试
- 用户体验测试
- 错误处理测试
- 性能指标验证

### 实施清单

#### 第一阶段实施清单
1. 创建 `backend/src/services/scheduling/core-course-engine.ts` 文件
2. 实现核心课程分类逻辑
3. 实现核心课程约束管理
4. 实现核心课程排课算法
5. 修改 `scheduling-engine.ts` 集成核心引擎
6. 更新 `types.ts` 添加相关类型定义
7. 测试核心课程排课功能

#### 第二阶段实施清单
8. 创建 `backend/src/services/scheduling/general-course-engine.ts` 文件
9. 实现一般课程分类逻辑
10. 实现基于现有排课的约束调整
11. 实现一般课程排课算法
12. 创建 `constraint-manager.ts` 约束管理类
13. 实现约束分层和动态调整
14. 集成到主排课流程
15. 测试两阶段排课功能

#### 第三阶段实施清单
16. 创建 `backend/src/services/scheduling/special-requirements-engine.ts` 文件
17. 实现特殊需求识别和处理
18. 实现局部优化算法（遗传算法/模拟退火）
19. 实现手动调整建议生成
20. 集成特殊需求处理到主流程
21. 测试三阶段完整排课功能

#### 第四阶段实施清单
22. 更新前端智能排课页面界面
23. 添加阶段进度显示组件
24. 实现分阶段配置界面
25. 添加排课质量指标展示
26. 更新后端API路由
27. 实现分阶段排课接口
28. 添加性能监控和优化
29. 集成测试和性能测试

#### 第五阶段实施清单
30. 代码审查和最终测试
31. 准备数据库迁移脚本
32. 更新生产环境配置
33. 部署新版本系统
34. 性能监控和指标验证
35. 用户验收测试
36. 文档更新和培训
37. 系统稳定性和监控

### 风险评估与应对策略

#### 技术风险
- **算法复杂度**: 分阶段可能增加总体复杂度
  - 应对：严格控制各阶段复杂度，避免过度设计
- **数据一致性**: 阶段间数据传递可能出错
  - 应对：实现严格的数据验证和回滚机制

#### 性能风险
- **阶段间开销**: 多阶段可能增加总执行时间
  - 应对：优化阶段间数据传输，减少序列化开销
- **内存使用**: 多引擎可能增加内存占用
  - 应对：实现内存池和垃圾回收优化

#### 兼容性风险
- **现有功能**: 新算法可能影响现有功能
  - 应对：保持向后兼容，提供回退机制
- **数据格式**: 新数据结构可能不兼容
  - 应对：实现数据迁移和版本兼容

### 成功标准

#### 技术指标
- 排课成功率提升至95%以上
- 平均执行时间减少50%以上
- 最大迭代次数控制在5000次以内
- 系统稳定性达到99.9%

#### 业务指标
- 用户满意度提升至90%以上
- 排课效率提升60%以上
- 手动调整需求减少80%以上
- 系统可用性达到99.5%

### 总结

这个分阶段排课算法执行计划将显著提升智能排课系统的性能和成功率。通过将复杂问题分解为可管理的子问题，我们可以：

1. **提升排课质量**: 核心课程优先保证教学质量
2. **提高执行效率**: 减少搜索空间和迭代次数
3. **增强系统稳定性**: 分阶段处理降低系统压力
4. **改善用户体验**: 清晰的进度反馈和配置选项

整个计划预计需要10周时间，分5个阶段逐步实施，确保系统稳定性和功能完整性。